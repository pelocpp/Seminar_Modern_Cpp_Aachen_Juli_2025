=========================

Modern C++

Peter Loos

Pascal, C/C++, Java, C#, JavaScript (Python) 

Guten Morgen

=========================

12.30 ...

=========================

== Visual Studio 2022 

== Github:   pelocpp

=========================

Agenda

Übungen  ... 

MT

Weak_Ptr: Dann machen wir ihn.

Templates

STL: Container // std::vector // map // ..

Keine Algorithmen:  std::fill, std::generate, std::transform,

==> Go for STL Algorithmen

a) STL Algorithmen

b) Überarbeitung: std::ranges

Performanz:

Speicher:

==> Fragen 

======================================

ToDo_Liste:
-----------

1) Werden die Elemente in diesem Zusammenhang kopiert oder verschoben ???

2) noexcept

3) requires

======================================

Dienstag:

 == Generische Funktionen (inkl. Lambdas)

 == Algorithmen zu Ende

 == Initializer_List

======================================



"Heftig"

b) Move-Semantik  // a) RValue-Referenz

Verwende ich nicht ...


std::string&:    LValue-Referenz (Left of an Assignment)

Ab C++ 11:  Zweiten Referenz-Typus

Eine Referenz (C++) ist ein Alias
für ein anderes, benanntes Objekt:

std::string&&:    RValue-Referenz (Right of an Assignment)

Why ???????????????????????????????????????????

Move-Semantik:

Man kann mit ihrer Hilfe Objekte verschieben (C++ 11)
und so unnütze Kopien vermeiden.

Adressen:

... 0B0:  Lokal am Stack // wird freigegeben
... 270:  Ist im Vektor

... 510


Rule-of-Zero:     Yes
//Rule-of-Three:  Yes
//Rule-of-Five:   Better

class Point
{
    int m_x;
    int m_y;

    std::string m_name;

    //  int* m_data;  // new
    std::shared_ptr m_data;  // new
};

// =================

new // Daten am Heap

Objekten, die man kopieren kann oder will
Enthalten Daten.

a) a = b;        // Keine Relevanz

b) func (data);  // Keine Relevanz

data calculation_data (...);

c) func (  calculation_data()  );

Ablauf: 
a)  calculation_data() legt ERGEBNIS am Stack an.

    Wird nach func kopiert.

b) Egebnis wird nach func VERSCHOBEN.

==============================================

std::vector<BigData> vec;

Beobachtungen:

a) std::vector<T> (STL) hat mal generell 
   eine WERT-Semantik zu Grunde liegen.

b) Große Datenmengen liegen am HEAP oder
   als Globale Variablen.

c) Prinzipiell geht auch std::vector<T*>

   Dann muss man das new und delete selbst verwalten.


i) std::vector<T> mit vielen, großen Daten: 

a) Wo liegt der Vektor selbst: global oder auch am Heap

b) Wie groß sind die Daten im Vektor ???

   Kleine Daten: std::vector<T>

   Große Daten: std::vector<T*>

===============================================

reserve 

===============================================

C++:  

== objekt orientierte 

Stroustrup

== generisch // Templates

Stepanov: generische Programmierung

Bibliothek: C++ STL  Standard Template Library

===============================================

std::string s("ABC");

std::string s { "ABC" };

Neuen Ansatz:   Neues Symbol: ( => {



Achtung:

Es gibt da auch noch eine Liste.

== Einheitliche Initialisierung
   - Uniform Initialization
   - Brace Initialization

== std::initializer_list (Listensyntax)


Frage:

rep stos    byte ptr [rdi]   oder memset ???

Ich glaube, dass memset intern auf rep stos
abgebildet wird.

Frage:

int- Array

Vorbelegung mit 123 für alle Werte

Geht das mit memset ??? 

===================================================

Lambda:

Umgangssprachlich: eine Lambda Funktion

Exakt:             ein Lambda Objekt

Wie sind Lambdas in C++ integriert ???

Herleitung.

a) mit freier Funktion

b) aufrufbares Objekt // Callable // callable Object

Algorithmen // Iterator

=====================================

Vergleich:

    static bool compare (int n1, int n2) {

        int tmp = n1;
00007FF644A04613  mov         eax,dword ptr [n1]  
00007FF644A04619  mov         dword ptr [tmp],eax  

    static bool compare (int& n1, int& n2) {

        int tmp = n1;
00007FF6FEC44614  mov         rax,qword ptr [n1]  
00007FF6FEC4461B  mov         eax,dword ptr [rax]  
00007FF6FEC4461D  mov         dword ptr [tmp],eax  

Mit Referenz ist es ein INDIREKTER Zugriff.


======================================================

Tool: Cpp Insights


======================================================

9 => 13 => 19 => 28 => 42 => 63

neuer Wert = alter Wert * 1.5;


9 => 13 => 19 => 28 => 42 => 63

Das könnte, sollte man vermeiden ....

====================================

STL:

Sequential Container: 

Assoziative Container: 

STL Container

STL Iteratoren

STL Algorithmen


Beobachtung:

STL Container

     ||

STL Iteratoren

     ||

STL Algorithmen

Beobachtung: "for each"  // Range-based for-Loop

STL Container

==============================================

STL Algorithmen:

Bei Kopieren, Transformieren:

==> Ziel:

a) push_back ans Ende angefügt

b) operator= an der jeweiligen Stelle zugewiesen.

   Voreinstellung.

Wie gelange ich zu a).

==============================================

Smart Pointer:

std::shared_ptr

std::weak_ptr:     Verwenden wir nicht :)


std::shared_ptr: Der funktioniert nicht immer ???

i)  std::weak_ptr

ii) Whyyyyyyyyyyyyyyyyyyyyyyyy: Was ist das Problem ???


======================================

Observer Pattern:

a) Objekt mit Zustand, der sich ändert und den man
   beobachten möchte: Ereignis Quelle

b) Es gibt Beobachter, die sich für
   Änderungen des Zustands der Ereignis Quelle interessieren.

c) Um beobachten zu können, müssen sich Beobachter
   an der Ereignis Quelle anmelden.

d) Beobachter werden in der Ereignis Quelle augehoben (Liste) 

I)  Beobachter kennen die Ereignis Quelle.
II) Eine Ereignis Quelle kennt Beobachter (anmelden).

Fragen zur Umsetzung:
=====================

Ereignis Quelle:  std::shared_ptr.

Beobachter:       std::shared_ptr.

In der Ereignis Quelle gibt es eine Liste
der Beobachter:

std::list<std::weak_ptr> m_observers;

Folge:

Ein Ereignis tritt ein:

==> Alle Beobachter zu benachrichtigen:

m_observers[i].lock()  => std::shared_ptr

a) std::shared_ptr: Is Empty => Nix zu tun
b) std::shared_ptr: Is NOT Empty => Kann Rückruf erfolgen.

===========================================

Nehme ich prinzipiell in meiner Anwendung
einen std::shared_ptr oder einen std::weak_ptr ???

A) Noch besser: Ginge std::unique_ptr !

B) Einfacher im Umgang // rumschieben .....

C) std::shared_ptr nur dann, wenn ich GRÜNDE
   für den Besitz habe.

D) So oft es geht: std::weak_ptr.

   i)  KEIN Besitz.
   ii) Wenn Zugang zum Objekt nicht mehr möglich: 
       Ist von der SW beherrschbar.

       Visualisierung: ste::weak_ptr

===================================================

std::vector<int>               ==> HEAP (new / delete)

std::initializer_list<int>     ==> STACK

Why ?????? ==> PERFORMANZ

===================================================

PERFORMANZ:

std::vector<int>               ==> HEAP (new / delete)
std::initializer_list<int>     ==> STACK

std::string
std::string_view

std::vector<int> 
std::span<int>

===================================================

std::vector<int> vec { 10 }; Size: 1, Elem: 10

std::vector<int> vec (10);   Size: 10 - Elemente: 0

===================================================

Structured Binding:

==================================================

Ein std::tuple ist ähnlich zu einer struct
für Schreibfaule.

==================================================

DTO:   Data Transfer Object   ===> std::tuple

10 Ebenen  // Restful Service REST API // Web Service

Interface Overkill

==================================================

Konstante:

123

123l

123ll

123.123f

100_km

100_kg

100_kilogramm

100_sekunden

100_euro

90_cent   ===> elem. Datentyp // int size_t

100_euro + 90_cent

0xFF0000_farbe   // ===>  class Color

0xFF0000_rgb

"100"_euro

"14:50:0"_uhrzeit

"100_euro_20_ct"_currency

"100.20"_currency

"100"_currency

".10"_currency  

"ABC"s


=================================

Lexikon:   bezeichner , +, -, *, 
 
           123 124

C++:   Man kann das Lexikon erweitern :)

=================================

operator""     Literal-Operator

TYPE   operator""   bezeichner  (params);

TYPE   operator""   _euro  (params);

UDL:  User Defined Literal

==================================

https://github.com/pelocpp/cpp_clean_performant_secure/blob/master/Clean_Performant_Code/Guidelines/Guidelines_Core_Cpp.md

Schlüsselwort auto: Left-to-Right Initialisierungsstil

==================================

Type Traits

==================================

std::variant:

Kann Daten unterschiedlichen Typs aufnehmen,
aber zu einem Zeitpunkt nur EIN Datum.

Beispiel:

Zelle /  Cell:

num. Wert // Datum // Uhrzeit // Currency ...

// ===============

Datentypen zur Laufzeit oder Übersetzungszeit

Reflection:

experimental Include

Java, C#: Sehr stark ausgeprägt.

C++: Für Arme

C++ 26: Die große Überarbeitung.

========================================

Variadische Templates:

a) verstehen / kennen lernen / lesen können

b) anwenden

Beobachtung:

Pro Funktion mit unterschiedlichen Parametern
muss im Maschinencode eine passende Funktion 
vorhanden sein.

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

==> Transport von Daten von A nach B
    ( beliebig viele, beliebigen Datentyps )

// ===============================================

Transport der Daten von A nach B.

Schlecht: Als Kopie.

Gut: Als Referenz // Problem mit RValues.

             Problem mit Konstanten, tmp. Objekten,
             mit allem, was keinen Namen hat.

Universal Referenz:
===================

==>  Perfekte Weiterleiten // Transportieren

================================================

Zeichenkette:

"11111111111111111111111111111111111111"


std::string s = "11111111111111111111111111111111111111";

const char* s = "11111111111111111111111111111111111111";

Im statischen Speicher 

Code-Segment.

Wo liegt "11111111..." NICHT: Im Heap

Optimierung:

std::string s = "11111111111111111111111111111111111111";

Von C nach C++:

no more strcpy, .................

std::string: Performance Penalty: HEAP

Performanz:

const char* s = "11111111111111111111111111111111111111";

Fehlt: Länge

==>

std::string_view:

2 Daten:

a) const char*  = Anfangsadresse 
b) size_t       = Länge

Wenn nicht wirklich mit Zeichenketten
gearbeitet werden soll:

Go for std::string_view

Achtung mit den Adressen, die ein
std::string_view Objekt verwaltet:

a) diese müssen GÜLTIG sein !!!!

Formulierung: 

Ein std::string_view Objekt ist ein NON-Owning Object.

==============================================

Frage:

Arrays:

C-Style Array's:     int numbers[10];

                     int n = 20;
                     numbers[n] = 123;

Klasse std::array

Gibt es bei "grober" Betrachtung einen Unterschied: NEIN

Fixed-Size Arrays:   std::array<int, 10> numbers;


===> std::array hat Vorteile.

a) Kennt die Länge.


b) Überprüft den Index:

 int n = 20;
 numbers[n] = 123;  // hier NICHT !!!

 numbers.at(n) = 123;

=======================================

std::variant: Container für unterschiedliche Daten.

std::any:     Container für unterschiedliche Daten.

=======================================

std::optional

int value;

std::string value;

...

// habe ich einen Wert ???

if (value == 0) ...

if (value == -1) ...

if (value == "") ...

Optimale Lösung:

int  value;
bool flag;    // true / false

std::optional<int>

=================================================

Folding:
=======

Ziel:

Wiederholte Anwendung eines Operators:

int sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10;

std::string_builder //  std::stringstream 

auto result = std::string{"1"} + "2" + "3" + "4" + "5";

auto result = mat1 + mat2 + mat3;


Umsetzung: Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

Folding:
--------

a) Wiederholte Anwendung eines Operators

b) Wiederholte Ausführung eines Ausdrucks   // Sequenz

Fazit:

Folding für schnelle arith. Ausdrücke mit EINEM Operator.

=====================================================

Das Parameter Pack:
====================

== einpacken, auspacken

Ein Parameter Pack ist eine komma getrennte Liste.

Beim Einpacken:  zB sieht man das bei einem Aufruf einer Funktion.


Auspacken:

zB beim Weiterleiten: my_make_unique ==> Konstr. Aufruf

zB in einer std::initializer_list

======================================================

Schnittstellen:

A la C#

interface IEnumerable
{
    abstract bool hasNext();
    abstract void moveNext();
    abstract void reset();
    abstract Object getValue();
}

A la C++:

class IEnumerable
{
    virtual bool hasNext() = 0;
    virtual void moveNext() = 0;
    virtual void reset() = 0;
    virtual Object getValue() = 0;
}

Oder:

class IntegerIterable
{
public:
    virtual bool hasNext() const = 0;
    virtual int  next() = 0;
    virtual void reset() = 0;
};

C++20 and Beyond:  Konzept für IEnumerable.

template <typename T>
concept IsIterable = requires (T v, bool b)
{
    { std::as_const(v).hasNext() } -> std::convertible_to<bool>;
    { v.next() } -> std::same_as<int>;
    { v.reset(b) }-> std::convertible_to<void>;
};

====================================================

== Verabschiedung

== KLeinigkeiten

== All-In: Polymorphismus: 

== MT

== Fading out ...


